/**
 * YouTube Scraper using yt-dlp
 * Requires Python + yt-dlp installed on server
 * 
 * NOTE: Cache is handled at the route level (lib/cache.ts), not in scrapers.
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import fs from 'fs/promises';
import os from 'os';
import { createError, ScraperErrorCode, type ScraperResult, type ScraperOptions } from '@/core/scrapers/types';
import { cookiePoolGetRotating, cookiePoolMarkSuccess, cookiePoolMarkError, cookiePoolMarkExpired } from '@/lib/cookies';
import { logger } from '../shared/logger';

const execAsync = promisify(exec);

/**
 * Convert cookie string to Netscape format for yt-dlp
 * Supports:
 * - Raw cookie string: "name1=value1; name2=value2"
 * - JSON array: [{"name": "...", "value": "...", "domain": "..."}]
 * - Already Netscape format (starts with # Netscape)
 */
function convertToNetscapeFormat(cookieData: string): string {
    const trimmed = cookieData.trim();
    
    // Already Netscape format - check for header or tab-separated lines
    if (trimmed.startsWith('# Netscape') || trimmed.startsWith('# HTTP Cookie File')) {
        return trimmed;
    }
    
    // Check if it looks like Netscape format (tab-separated with 7 fields)
    const firstLine = trimmed.split('\n')[0];
    if (firstLine.includes('\t') && firstLine.split('\t').length >= 7) {
        // Already Netscape format without header, add header
        return `# Netscape HTTP Cookie File\n# https://curl.se/docs/http-cookies.html\n\n${trimmed}`;
    }
    
    // Netscape header
    const lines: string[] = [
        '# Netscape HTTP Cookie File',
        '# https://curl.se/docs/http-cookies.html',
        '# This file was generated by DownAria',
        '',
    ];
    
    const domain = '.youtube.com';
    const expiry = Math.floor(Date.now() / 1000) + 86400 * 365; // 1 year from now
    
    // Try JSON format first
    if (trimmed.startsWith('[')) {
        try {
            const cookies = JSON.parse(trimmed) as Array<{
                name: string;
                value: string;
                domain?: string;
                path?: string;
                secure?: boolean;
                httpOnly?: boolean;
                expirationDate?: number;
            }>;
            
            for (const c of cookies) {
                if (!c.name || !c.value) continue;
                
                const cookieDomain = c.domain || domain;
                const cookiePath = c.path || '/';
                const secure = c.secure !== false ? 'TRUE' : 'FALSE'; // Default to TRUE for YouTube
                const exp = c.expirationDate ? Math.floor(c.expirationDate) : expiry;
                // Netscape format: domain, flag, path, secure, expiry, name, value
                // flag = TRUE if domain starts with dot (subdomain matching)
                const flag = cookieDomain.startsWith('.') ? 'TRUE' : 'FALSE';
                lines.push(`${cookieDomain}\t${flag}\t${cookiePath}\t${secure}\t${exp}\t${c.name}\t${c.value}`);
            }
            
            logger.debug('youtube', `Converted ${cookies.length} JSON cookies to Netscape format`);
            return lines.join('\n');
        } catch (e) {
            logger.warn('youtube', `Failed to parse JSON cookies: ${e}`);
            // Not valid JSON, try raw format
        }
    }
    
    // Raw cookie string format: "name1=value1; name2=value2"
    // Split by semicolon (with or without space)
    const cookiePairs = trimmed.split(/;\s*/);
    let convertedCount = 0;
    
    for (const pair of cookiePairs) {
        if (!pair.trim()) continue;
        
        const eqIndex = pair.indexOf('=');
        if (eqIndex === -1) continue;
        
        const name = pair.substring(0, eqIndex).trim();
        const value = pair.substring(eqIndex + 1).trim();
        
        if (!name) continue;
        // Allow empty values (some cookies have empty values)
        
        // Determine secure flag based on cookie name
        const isSecure = name.startsWith('__Secure-') || name.startsWith('__Host-') || 
                         ['SID', 'SSID', 'HSID', 'SAPISID', 'APISID', 'LOGIN_INFO'].includes(name);
        const secure = isSecure ? 'TRUE' : 'FALSE';
        
        // Netscape format: domain, flag, path, secure, expiry, name, value
        // Use TRUE for flag (subdomain matching)
        lines.push(`${domain}\tTRUE\t/\t${secure}\t${expiry}\t${name}\t${value}`);
        convertedCount++;
    }
    
    logger.debug('youtube', `Converted ${convertedCount} raw cookies to Netscape format`);
    return lines.join('\n');
}

interface YtdlpFormat {
    format_id: string;
    quality: string;
    ext: string;
    filesize: number | null;
    url: string;
    type: 'video' | 'audio';
    height: number | null;
    width: number | null;
    fps: number | null;
    vcodec: string | null;
    acodec: string | null;
    abr: number | null;
}

// Typical bitrates for YouTube video streams (in kbps)
// Based on actual YouTube encoding (AV1/VP9 - very efficient codecs)
// These are CONSERVATIVE estimates - actual files are often smaller
// AV1 is ~30-50% more efficient than VP9, VP9 is ~30% more efficient than H.264
const VIDEO_BITRATES: Record<number, number> = {
    2160: 8000,   // 4K: ~8 Mbps (AV1 actual: 5-12 Mbps)
    1440: 4000,   // 2K: ~4 Mbps (AV1 actual: 3-6 Mbps)
    1080: 2000,   // FHD: ~2 Mbps (AV1 actual: 1.5-3 Mbps)
    720: 1200,    // HD: ~1.2 Mbps (AV1 actual: 0.8-1.5 Mbps)
    480: 600,     // SD: ~600 kbps (AV1 actual: 300-800 kbps)
    360: 350,     // Low: ~350 kbps (AV1 actual: 200-500 kbps)
    240: 200,     // Very low: ~200 kbps
    144: 100,     // Potato: ~100 kbps
};

const AUDIO_BITRATE = 128; // kbps for audio track


/**
 * Estimate filesize based on resolution and duration
 * Formula: (video_bitrate + audio_bitrate) * duration / 8
 * Returns bytes
 */
function estimateFilesize(height: number, duration: number, includeAudio: boolean = true): number {
    // Find closest bitrate
    const heights = Object.keys(VIDEO_BITRATES).map(Number).sort((a, b) => b - a);
    let videoBitrate = VIDEO_BITRATES[360]; // default
    
    for (const h of heights) {
        if (height >= h) {
            videoBitrate = VIDEO_BITRATES[h];
            break;
        }
    }
    
    const totalBitrate = videoBitrate + (includeAudio ? AUDIO_BITRATE : 0);
    // bitrate (kbps) * duration (seconds) / 8 = bytes / 1000
    return Math.round((totalBitrate * duration * 1000) / 8);
}

interface YtdlpResult {
    success: boolean;
    error?: string;
    data?: {
        id: string;
        title: string;
        description?: string;
        author: string;
        duration: number;
        thumbnail: string;
        view_count: number;
        like_count: number;
        formats: YtdlpFormat[];
    };
}

/**
 * Scrape YouTube video using yt-dlp
 */
export async function scrapeYouTube(url: string, options?: ScraperOptions): Promise<ScraperResult> {
    // Validate URL
    if (!isYouTubeUrl(url)) {
        return createError(ScraperErrorCode.INVALID_URL, 'Invalid YouTube URL');
    }

    let cookieFilePath: string | null = null;
    let usedCookie = false;

    try {
        // Clean URL - remove playlist parameter to speed up extraction
        const cleanUrl = cleanYouTubeUrl(url);
        
        // Path to Python script
        const scriptPath = path.join(process.cwd(), 'scripts', 'ytdlp-extract.py');
        
        // Escape URL for shell
        const escapedUrl = cleanUrl.replace(/"/g, '\\"');
        
        // Execute Python script (use 'python' on Windows, 'python3' on Linux/Mac)
        const pythonCmd = process.platform === 'win32' ? 'python' : 'python3';
        
        // Try to get cookie from pool for age-restricted/private videos
        const poolCookie = await cookiePoolGetRotating('youtube');
        if (poolCookie) {
            // Write cookie to temp file for yt-dlp (Netscape format)
            const tempDir = os.tmpdir();
            cookieFilePath = path.join(tempDir, `yt-cookie-${Date.now()}.txt`);
            
            // Log cookie format for debugging
            const cookiePreview = poolCookie.substring(0, 50);
            const isJson = poolCookie.trim().startsWith('[');
            const isNetscape = poolCookie.trim().startsWith('#');
            logger.debug('youtube', `Cookie format: ${isJson ? 'JSON' : isNetscape ? 'Netscape' : 'Raw'}, preview: ${cookiePreview}...`);
            
            // Convert cookie string to Netscape format
            const netscapeCookie = convertToNetscapeFormat(poolCookie);
            
            // Log converted format
            const lineCount = netscapeCookie.split('\n').filter(l => l && !l.startsWith('#')).length;
            logger.debug('youtube', `Converted to Netscape: ${lineCount} cookie entries`);
            
            await fs.writeFile(cookieFilePath, netscapeCookie, 'utf-8');
            usedCookie = true;
        }
        
        logger.debug('youtube', `Extracting with yt-dlp: ${cleanUrl}`);
        const startTime = Date.now();

        // Build command with optional cookie file
        let cmd = `${pythonCmd} "${scriptPath}" "${escapedUrl}"`;
        if (cookieFilePath) {
            cmd += ` "${cookieFilePath}"`;
        }

        const { stdout, stderr } = await execAsync(cmd, { 
            timeout: 90000, // 90s timeout (YouTube can be slow)
            maxBuffer: 10 * 1024 * 1024, // 10MB buffer
        });
        
        const extractTime = Date.now() - startTime;
        logger.debug('youtube', `yt-dlp extraction took ${extractTime}ms`);

        if (stderr) {
            logger.warn('youtube', `yt-dlp stderr: ${stderr}`);
        }

        // Parse result
        const ytdlpResult: YtdlpResult = JSON.parse(stdout);

        if (!ytdlpResult.success || !ytdlpResult.data) {
            // Check for cookie-related errors
            const errorMsg = ytdlpResult.error?.toLowerCase() || '';
            if (usedCookie && (errorMsg.includes('sign in') || errorMsg.includes('login') || errorMsg.includes('cookie'))) {
                cookiePoolMarkExpired('YouTube cookie expired or invalid').catch(() => {});
            } else if (usedCookie) {
                cookiePoolMarkError(ytdlpResult.error).catch(() => {});
            }
            return createError(ScraperErrorCode.PARSE_ERROR, ytdlpResult.error || 'Failed to extract video');
        }

        // Mark cookie as successful if used
        if (usedCookie) {
            cookiePoolMarkSuccess().catch(() => {});
        }

        const { data } = ytdlpResult;

        // Separate formats by type
        const rawFormats = data.formats.filter(f => f.url);
        
        // Find combined formats (has both video and audio codec)
        const combinedFormats = rawFormats.filter(f => 
            f.vcodec && f.vcodec !== 'none' && f.acodec && f.acodec !== 'none'
        );
        
        // Find video-only formats (no audio)
        const videoOnlyFormats = rawFormats.filter(f => 
            f.vcodec && f.vcodec !== 'none' && (!f.acodec || f.acodec === 'none')
        );
        
        // Find audio-only formats
        const audioOnlyFormats = rawFormats.filter(f => 
            f.acodec && f.acodec !== 'none' && (!f.vcodec || f.vcodec === 'none')
        );
        
        // Get best audio for merging (highest bitrate)
        const bestAudio = audioOnlyFormats
            .sort((a, b) => (b.abr || 0) - (a.abr || 0))[0];

        // Build final formats list - ONLY playable formats for users
        const finalFormats: Array<{
            url: string;
            quality: string;
            type: 'video' | 'audio';
            format: string;
            filesize?: number;
            filesizeEstimated?: boolean;
            width?: number;
            height?: number;
            needsMerge?: boolean;
            audioUrl?: string;
        }> = [];
        
        const duration = data.duration || 0;
        
        // Track seen qualities to avoid duplicates
        const seenQualities = new Set<string>();
        
        // 1. Add combined formats (playable as-is) - prioritize these
        for (const f of combinedFormats) {
            const qualityKey = `combined-${f.height}p-${f.ext}`;
            if (seenQualities.has(qualityKey)) continue;
            seenQualities.add(qualityKey);
            
            // Use yt-dlp filesize (accurate) or estimate as fallback
            const hasActualSize = f.filesize && f.filesize > 0;
            const filesize = hasActualSize 
                ? f.filesize! 
                : (f.height && duration ? estimateFilesize(f.height, duration, true) : undefined);
            
            finalFormats.push({
                url: f.url,
                quality: f.quality || `${f.height}p`,
                type: 'video',
                format: f.ext,
                filesize,
                filesizeEstimated: !hasActualSize && !!filesize,
                width: f.width || undefined,
                height: f.height || undefined,
            });
        }

        // 2. Add video-only formats that need merge (ALL resolutions)
        // Only add if we have audio to merge with
        // Deduplicate by height, prefer mp4 over webm
        if (bestAudio) {
            // Group by height, pick best format per height
            const byHeight = new Map<number, typeof videoOnlyFormats[0]>();
            
            for (const f of videoOnlyFormats) {
                // Include ALL video-only formats (they all need merge for audio)
                if (!f.height) continue;
                
                const existing = byHeight.get(f.height);
                if (!existing) {
                    byHeight.set(f.height, f);
                } else {
                    // Prefer mp4 over webm
                    if (f.ext === 'mp4' && existing.ext !== 'mp4') {
                        byHeight.set(f.height, f);
                    }
                    // If same ext, prefer smaller file (usually better codec)
                    else if (f.ext === existing.ext && (f.filesize || 0) < (existing.filesize || Infinity)) {
                        byHeight.set(f.height, f);
                    }
                }
            }
            
            // Add deduplicated formats
            for (const f of byHeight.values()) {
                const qualityKey = `merge-${f.height}p`;
                if (seenQualities.has(qualityKey)) continue;
                seenQualities.add(qualityKey);
                
                // Use yt-dlp filesize (accurate) - add video + audio size for merged output
                const videoSize = f.filesize && f.filesize > 0 ? f.filesize : undefined;
                const audioSize = bestAudio.filesize && bestAudio.filesize > 0 ? bestAudio.filesize : undefined;
                
                let filesize: number | undefined;
                let isEstimated = false;
                
                if (videoSize && audioSize) {
                    // Both sizes from yt-dlp - exact total
                    filesize = videoSize + audioSize;
                } else if (videoSize) {
                    // Only video size - estimate audio
                    const estimatedAudio = duration ? Math.round((AUDIO_BITRATE * duration * 1000) / 8) : Math.round(videoSize * 0.1);
                    filesize = videoSize + estimatedAudio;
                    isEstimated = true;
                } else {
                    // Fallback to full estimate
                    filesize = f.height && duration ? estimateFilesize(f.height, duration, true) : undefined;
                    isEstimated = true;
                }
                
                finalFormats.push({
                    url: f.url,
                    quality: `${f.height}p`,
                    type: 'video',
                    format: 'mp4', // Always output as mp4 after merge
                    filesize,
                    filesizeEstimated: isEstimated,
                    width: f.width || undefined,
                    height: f.height || undefined,
                    needsMerge: true,
                    audioUrl: bestAudio.url,
                });
            }
        }

        // 3. Add audio formats for audio-only download
        // Show M4A (best quality) + MP3 (compatible) options
        if (audioOnlyFormats.length > 0) {
            // Get best audio (highest bitrate)
            const bestAudioFormat = audioOnlyFormats
                .filter(f => f.abr && f.abr > 0)
                .sort((a, b) => (b.abr || 0) - (a.abr || 0))[0];
            
            if (bestAudioFormat) {
                // Use yt-dlp filesize (accurate)
                const hasActualSize = bestAudioFormat.filesize && bestAudioFormat.filesize > 0;
                const bitrate = Math.round(bestAudioFormat.abr || 128);
                const audioFilesize = hasActualSize 
                    ? bestAudioFormat.filesize! 
                    : (duration ? Math.round((bitrate * duration * 1000) / 8) : undefined);
                
                // Option 1: M4A (AAC) - best quality, good compatibility
                finalFormats.push({
                    url: bestAudioFormat.url,
                    quality: 'M4A',
                    type: 'audio',
                    format: 'm4a',
                    filesize: audioFilesize,
                    filesizeEstimated: !hasActualSize && !!audioFilesize,
                });
                
                // Option 2: MP3 - most compatible (converted, so always estimated)
                finalFormats.push({
                    url: bestAudioFormat.url,
                    quality: 'MP3',
                    type: 'audio',
                    format: 'mp3',
                    filesize: audioFilesize ? Math.round(audioFilesize * 0.9) : undefined,
                    filesizeEstimated: true, // Always estimated because it's converted
                });
            }
        }

        // Deduplicate by height - ALWAYS prefer needsMerge (has filesize from yt-dlp)
        // Combined formats rarely have filesize, needsMerge formats always do
        const heightMap = new Map<number, typeof finalFormats[0]>();
        for (const f of finalFormats) {
            if (f.type !== 'video' || !f.height) continue;
            const existing = heightMap.get(f.height);
            if (!existing) {
                heightMap.set(f.height, f);
            } else {
                // Always prefer format with filesize
                if (f.filesize && !existing.filesize) {
                    heightMap.set(f.height, f);
                }
                // If both have filesize or both don't, prefer needsMerge (better quality)
                else if ((!!f.filesize === !!existing.filesize) && f.needsMerge && !existing.needsMerge) {
                    heightMap.set(f.height, f);
                }
            }
        }
        
        // Rebuild formats: deduplicated videos + audio
        // Filter out 144p and 240p (useless quality)
        const deduplicatedFormats = [
            ...Array.from(heightMap.values()).filter(f => !f.height || f.height >= 360),
            ...finalFormats.filter(f => f.type === 'audio')
        ];
        
        // Sort by height desc
        deduplicatedFormats.sort((a, b) => {
            // Audio last
            if (a.type === 'audio' && b.type !== 'audio') return 1;
            if (a.type !== 'audio' && b.type === 'audio') return -1;
            // Then by height
            return (b.height || 0) - (a.height || 0);
        });
        
        // Replace finalFormats
        finalFormats.length = 0;
        finalFormats.push(...deduplicatedFormats);

        const result: ScraperResult = {
            success: true,
            data: {
                title: data.title,
                description: data.description || undefined,
                author: data.author,
                thumbnail: data.thumbnail,
                url,
                formats: finalFormats,
                engagement: {
                    views: data.view_count,
                    likes: data.like_count,
                },
                usedCookie,
            },
        };

        logger.complete('youtube', Date.now());
        
        return result;

    } catch (error: unknown) {
        const err = error as { code?: string; killed?: boolean; message?: string };
        
        // Mark cookie error if used
        if (usedCookie) {
            const msg = err.message?.toLowerCase() || '';
            if (msg.includes('sign in') || msg.includes('login') || msg.includes('cookie')) {
                cookiePoolMarkExpired('YouTube cookie expired').catch(() => {});
            } else {
                cookiePoolMarkError(err.message).catch(() => {});
            }
        }
        
        // Handle specific errors
        if (err.code === 'ETIMEDOUT' || err.killed) {
            return createError(ScraperErrorCode.TIMEOUT, 'YouTube extraction timed out');
        }
        
        if (err.message?.includes('not found') || err.code === 'ENOENT') {
            return createError(ScraperErrorCode.API_ERROR, 'yt-dlp not installed on server');
        }

        // Check for yt-dlp specific errors
        const msg = err.message?.toLowerCase() || '';
        if (msg.includes('private') || msg.includes('sign in')) {
            return createError(ScraperErrorCode.PRIVATE_CONTENT, 'This video is private or requires login');
        }
        if (msg.includes('unavailable') || msg.includes('removed')) {
            return createError(ScraperErrorCode.NOT_FOUND, 'Video unavailable or removed');
        }
        if (msg.includes('age') || msg.includes('confirm your age')) {
            return createError(ScraperErrorCode.AGE_RESTRICTED, 'This video is age-restricted');
        }

        return createError(ScraperErrorCode.UNKNOWN, (err.message || 'Unknown error').substring(0, 200));
    } finally {
        // Cleanup temp cookie file
        if (cookieFilePath) {
            fs.unlink(cookieFilePath).catch(() => {});
        }
    }
}

/**
 * Clean YouTube URL - remove playlist and other slow parameters
 * This speeds up yt-dlp extraction significantly
 */
function cleanYouTubeUrl(url: string): string {
    try {
        const urlObj = new URL(url);
        
        // Handle youtu.be short URLs
        if (urlObj.hostname === 'youtu.be') {
            const videoId = urlObj.pathname.slice(1).split('/')[0];
            return `https://www.youtube.com/watch?v=${videoId}`;
        }
        
        // Handle youtube.com URLs - keep only 'v' parameter
        const videoId = urlObj.searchParams.get('v');
        if (videoId) {
            return `https://www.youtube.com/watch?v=${videoId}`;
        }
        
        // Handle /shorts/ URLs
        const shortsMatch = url.match(/\/shorts\/([a-zA-Z0-9_-]{11})/);
        if (shortsMatch) {
            return `https://www.youtube.com/watch?v=${shortsMatch[1]}`;
        }
        
        // Fallback - return original
        return url;
    } catch {
        return url;
    }
}


/**
 * Check if URL is YouTube
 */
export function isYouTubeUrl(url: string): boolean {
    return /(?:youtube\.com|youtu\.be|music\.youtube\.com)/i.test(url);
}

/**
 * Extract video ID from YouTube URL
 */
export function extractYouTubeId(url: string): string | null {
    const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
        /(?:youtube\.com\/v\/|youtube\.com\/e\/)([a-zA-Z0-9_-]{11})/,
        /(?:music\.youtube\.com\/watch\?v=)([a-zA-Z0-9_-]{11})/,
    ];

    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
    }

    return null;
}
